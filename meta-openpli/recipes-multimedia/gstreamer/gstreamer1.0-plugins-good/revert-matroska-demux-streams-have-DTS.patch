This revert patches in Bug 745192 - matroskademux: V_MS-VFW-FOURCC streams have DTS instead of PTS
https://bugzilla.gnome.org/show_bug.cgi?id=745192

--- a/gst/matroska/matroska-demux.c	2016-04-04 23:19:15.874984233 +0300
+++ b/gst/matroska/matroska-demux.c	2016-04-04 23:38:02.572571231 +0300
@@ -431,8 +431,6 @@
   context->from_offset = -1;
   context->to_offset = G_MAXINT64;
   context->alignment = 1;
-  context->dts_only = FALSE;
-  context->intra_only = FALSE;
   context->tags = gst_tag_list_new_empty ();
   demux->common.num_streams++;
   g_assert (demux->common.src->len == demux->common.num_streams);
@@ -3237,7 +3235,6 @@
   gint flags = 0;
   gint64 referenceblock = 0;
   gint64 offset;
-  GstClockTime buffer_timestamp;
 
   offset = gst_ebml_read_get_offset (ebml);
 
@@ -3635,15 +3632,7 @@
         goto next_lace;
       }
 
-      if (!stream->dts_only) {
-        GST_BUFFER_PTS (sub) = lace_time;
-      } else {
-        GST_BUFFER_DTS (sub) = lace_time;
-        if (stream->intra_only)
-          GST_BUFFER_PTS (sub) = lace_time;
-      }
-
-      buffer_timestamp = gst_matroska_track_get_buffer_timestamp (stream, sub);
+      GST_BUFFER_TIMESTAMP (sub) = lace_time;
 
       if (GST_CLOCK_TIME_IS_VALID (lace_time)) {
         GstClockTime last_stop_end;
@@ -3752,7 +3741,7 @@
           "Pushing lace %d, data of size %" G_GSIZE_FORMAT
           " for stream %d, time=%" GST_TIME_FORMAT " and duration=%"
           GST_TIME_FORMAT, n, gst_buffer_get_size (sub), stream_num,
-          GST_TIME_ARGS (buffer_timestamp),
+          GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (sub)),
           GST_TIME_ARGS (GST_BUFFER_DURATION (sub)));
 
 #if 0
@@ -3763,13 +3752,13 @@
 
         GST_LOG_OBJECT (demux, "adding association %" GST_TIME_FORMAT "-> %"
             G_GUINT64_FORMAT " for writer id %d",
-            GST_TIME_ARGS (buffer_timestamp), cluster_offset,
+            GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (sub)), cluster_offset,
             stream->index_writer_id);
         gst_index_add_association (demux->common.element_index,
             stream->index_writer_id, GST_BUFFER_FLAG_IS_SET (sub,
                 GST_BUFFER_FLAG_DELTA_UNIT) ? 0 : GST_ASSOCIATION_FLAG_KEY_UNIT,
-            GST_FORMAT_TIME, buffer_timestamp, GST_FORMAT_BYTES, cluster_offset,
-            NULL);
+            GST_FORMAT_TIME, GST_BUFFER_TIMESTAMP (sub), GST_FORMAT_BYTES,
+            cluster_offset, NULL);
       }
 #endif
 
@@ -3825,10 +3814,6 @@
         stream->pos = GST_BUFFER_PTS (sub);
         if (GST_BUFFER_DURATION_IS_VALID (sub))
           stream->pos += GST_BUFFER_DURATION (sub);
-      } else if (GST_BUFFER_DTS_IS_VALID (sub)) {
-        stream->pos = GST_BUFFER_DTS (sub);
-        if (GST_BUFFER_DURATION_IS_VALID (sub))
-          stream->pos += GST_BUFFER_DURATION (sub);
       }
 
       ret = gst_pad_push (stream->pad, sub);
@@ -5041,8 +5026,6 @@
         memcpy (vids, data, size);
       }
 
-      context->dts_only = TRUE; /* VFW files only store DTS */
-
       /* little-endian -> byte-order */
       vids->size = GUINT32_FROM_LE (vids->size);
       vids->width = GUINT32_FROM_LE (vids->width);
@@ -5073,12 +5056,6 @@
       if (caps == NULL) {
         GST_WARNING ("Unhandled RIFF fourcc %" GST_FOURCC_FORMAT,
             GST_FOURCC_ARGS (vids->compression));
-      } else {
-        static GstStaticCaps intra_caps = GST_STATIC_CAPS ("image/jpeg; "
-            "video/x-raw; image/png; video/x-dv; video/x-huffyuv; video/x-ffv; "
-            "video/x-compressed-yuv");
-        context->intra_only =
-            gst_caps_can_intersect (gst_static_caps_get (&intra_caps), caps);
       }
 
       if (buf)
@@ -5124,8 +5101,6 @@
         return NULL;
     }
 
-    context->intra_only = TRUE;
-
     gst_video_info_set_format (&info, format, videocontext->pixel_width,
         videocontext->pixel_height);
     caps = gst_video_info_to_caps (&info);
@@ -5180,7 +5155,6 @@
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_VIDEO_MJPEG)) {
     caps = gst_caps_new_empty_simple ("image/jpeg");
     *codec_name = g_strdup ("Motion-JPEG");
-    context->intra_only = TRUE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC)) {
     caps = gst_caps_new_empty_simple ("video/x-h264");
     if (data) {
--- a/gst/matroska/matroska-ids.c	2016-04-04 23:19:15.874984233 +0300
+++ b/gst/matroska/matroska-ids.c	2016-04-04 23:25:50.804942587 +0300
@@ -300,17 +300,6 @@
   return list;
 }
 
-GstClockTime
-gst_matroska_track_get_buffer_timestamp (GstMatroskaTrackContext * track,
-    GstBuffer * buf)
-{
-  if (track->dts_only) {
-    return GST_BUFFER_DTS_OR_PTS (buf);
-  } else {
-    return GST_BUFFER_PTS (buf);
-  }
-}
-
 void
 gst_matroska_track_free (GstMatroskaTrackContext * track)
 {
--- a/gst/matroska/matroska-ids.h	2016-04-04 23:19:15.874984233 +0300
+++ b/gst/matroska/matroska-ids.h	2016-04-04 23:26:10.649040998 +0300
@@ -570,12 +570,6 @@
 
   /* any alignment we need our output buffers to have */
   gint          alignment;
-  
-  /* for compatibility with VFW files, where timestamp represents DTS */
-  gboolean      dts_only;
-  
-  /* indicate that the track is raw (jpeg,raw variants) and so pts=dts */
-  gboolean		intra_only;
 };
 
 typedef struct _GstMatroskaTrackVideoContext {
@@ -674,6 +668,5 @@
 GstBufferList * gst_matroska_parse_flac_stream_headers  (gpointer codec_data,
                                                          gsize codec_data_size);
 void gst_matroska_track_free (GstMatroskaTrackContext * track);
-GstClockTime gst_matroska_track_get_buffer_timestamp (GstMatroskaTrackContext * track, GstBuffer *buf);
 
 #endif /* __GST_MATROSKA_IDS_H__ */
--- a/gst/matroska/matroska-mux.c	2016-04-04 23:19:15.878984257 +0300
+++ b/gst/matroska/matroska-mux.c	2016-04-04 23:36:25.412089436 +0300
@@ -1138,7 +1138,6 @@
     gst_matroska_mux_free_codec_priv (context);
     context->codec_priv = (gpointer) bih;
     context->codec_priv_size = size;
-    context->dts_only = TRUE;
   } else if (!strcmp (mimetype, "video/x-h264")) {
     gst_matroska_mux_set_codec_id (context,
         GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC);
@@ -2348,7 +2347,6 @@
   collect_pad->track = context;
   gst_matroska_pad_reset (collect_pad, FALSE);
   collect_pad->track->codec_id = id;
-  collect_pad->track->dts_only = FALSE;
 
   collect_pad->capsfunc = capsfunc;
   gst_pad_set_active (GST_PAD (newpad), TRUE);
@@ -3519,7 +3517,6 @@
   gboolean is_video_invisible = FALSE;
   GstMatroskamuxPad *pad;
   gint flags = 0;
-  GstClockTime buffer_timestamp;
   GstAudioClippingMeta *cmeta = NULL;
 
   /* write data */
@@ -3547,14 +3544,11 @@
     gst_buffer_resize (buf, 8, gst_buffer_get_size (buf) - 8);
   }
 
-  buffer_timestamp =
-      gst_matroska_track_get_buffer_timestamp (collect_pad->track, buf);
-
   /* hm, invalid timestamp (due to --to be fixed--- element upstream);
    * this would wreak havoc with time stored in matroska file */
   /* TODO: maybe calculate a timestamp by using the previous timestamp
    * and default duration */
-  if (!GST_CLOCK_TIME_IS_VALID (buffer_timestamp)) {
+  if (!GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
     GST_WARNING_OBJECT (collect_pad->collect.pad,
         "Invalid buffer timestamp; dropping buffer");
     gst_buffer_unref (buf);
@@ -3555,17 +3555,6 @@
     return GST_FLOW_OK;
   }
 
-  if (!strcmp (collect_pad->track->codec_id, GST_MATROSKA_CODEC_ID_AUDIO_OPUS)
-      && collect_pad->track->codec_delay) {
-    /* All timestamps should include the codec delay */
-    if (buffer_timestamp > collect_pad->track->codec_delay) {
-      buffer_timestamp += collect_pad->track->codec_delay;
-    } else {
-      buffer_timestamp = 0;
-      duration_diff = collect_pad->track->codec_delay - buffer_timestamp;
-    }
-  }
-
   /* set the timestamp for outgoing buffers */
   ebml->timestamp = GST_BUFFER_TIMESTAMP (buf);
 
@@ -3573,12 +3567,12 @@
   }
 
   /* set the timestamp for outgoing buffers */
-  ebml->timestamp = buffer_timestamp;
+  ebml->timestamp = GST_BUFFER_TIMESTAMP (buf);
 
   if (collect_pad->track->type == GST_MATROSKA_TRACK_TYPE_VIDEO) {
     if (!GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT)) {
       GST_LOG_OBJECT (mux, "have video keyframe, ts=%" GST_TIME_FORMAT,
-          GST_TIME_ARGS (buffer_timestamp));
+          GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
       is_video_keyframe = TRUE;
     } else if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DECODE_ONLY) &&
         (!strcmp (collect_pad->track->codec_id, GST_MATROSKA_CODEC_ID_VIDEO_VP8)
@@ -3586,7 +3580,7 @@
                 GST_MATROSKA_CODEC_ID_VIDEO_VP9))) {
       GST_LOG_OBJECT (mux,
           "have VP8 video invisible frame, " "ts=%" GST_TIME_FORMAT,
-          GST_TIME_ARGS (buffer_timestamp));
+          GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
       is_video_invisible = TRUE;
     }
   }
@@ -3595,7 +3589,7 @@
     /* start a new cluster at every keyframe, at every GstForceKeyUnit event,
      * or when we may be reaching the limit of the relative timestamp */
     if (mux->cluster_time +
-        mux->max_cluster_duration < buffer_timestamp
+        mux->max_cluster_duration < GST_BUFFER_TIMESTAMP (buf)
         || is_video_keyframe || mux->force_key_unit_event) {
       if (!mux->ebml_write->streamable)
         gst_ebml_write_master_finish (ebml, mux->cluster);
@@ -3612,11 +3606,13 @@
       mux->cluster =
           gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_CLUSTER);
       gst_ebml_write_uint (ebml, GST_MATROSKA_ID_CLUSTERTIMECODE,
-          gst_util_uint64_scale (buffer_timestamp, 1, mux->time_scale));
+          gst_util_uint64_scale (GST_BUFFER_TIMESTAMP (buf), 1,
+              mux->time_scale));
       GST_LOG_OBJECT (mux, "cluster timestamp %" G_GUINT64_FORMAT,
-          gst_util_uint64_scale (buffer_timestamp, 1, mux->time_scale));
-      gst_ebml_write_flush_cache (ebml, TRUE, buffer_timestamp);
-      mux->cluster_time = buffer_timestamp;
+          gst_util_uint64_scale (GST_BUFFER_TIMESTAMP (buf), 1,
+              mux->time_scale));
+      gst_ebml_write_flush_cache (ebml, TRUE, GST_BUFFER_TIMESTAMP (buf));
+      mux->cluster_time = GST_BUFFER_TIMESTAMP (buf);
       gst_ebml_write_uint (ebml, GST_MATROSKA_ID_PREVSIZE,
           mux->prev_cluster_size);
     }
@@ -3627,9 +3623,9 @@
     gst_ebml_write_set_cache (ebml, 0x20);
     mux->cluster = gst_ebml_write_master_start (ebml, GST_MATROSKA_ID_CLUSTER);
     gst_ebml_write_uint (ebml, GST_MATROSKA_ID_CLUSTERTIMECODE,
-        gst_util_uint64_scale (buffer_timestamp, 1, mux->time_scale));
-    gst_ebml_write_flush_cache (ebml, TRUE, buffer_timestamp);
-    mux->cluster_time = buffer_timestamp;
+        gst_util_uint64_scale (GST_BUFFER_TIMESTAMP (buf), 1, mux->time_scale));
+    gst_ebml_write_flush_cache (ebml, TRUE, GST_BUFFER_TIMESTAMP (buf));
+    mux->cluster_time = GST_BUFFER_TIMESTAMP (buf);
   }
 
   /* We currently write index entries for all video tracks or for the audio
@@ -3654,7 +3650,7 @@
     }
 
     if (last_idx < 0 || mux->min_index_interval == 0 ||
-        (GST_CLOCK_DIFF (mux->index[last_idx].time, buffer_timestamp)
+        (GST_CLOCK_DIFF (mux->index[last_idx].time, GST_BUFFER_TIMESTAMP (buf))
             >= mux->min_index_interval)) {
       GstMatroskaIndex *idx;
 
@@ -3665,7 +3661,7 @@
       idx = &mux->index[mux->num_indexes++];
 
       idx->pos = mux->cluster_pos;
-      idx->time = buffer_timestamp;
+      idx->time = GST_BUFFER_TIMESTAMP (buf);
       idx->track = collect_pad->track->num;
     }
   }
@@ -3687,7 +3683,7 @@
   /* write the block, for doctype v2 use SimpleBlock if possible
    * one slice (*breath*).
    * FIXME: Need to do correct lacing! */
-  relative_timestamp64 = buffer_timestamp - mux->cluster_time;
+  relative_timestamp64 = GST_BUFFER_TIMESTAMP (buf) - mux->cluster_time;
   if (relative_timestamp64 >= 0) {
     /* round the timestamp */
     relative_timestamp64 += gst_util_uint64_scale (mux->time_scale, 1, 2);
@@ -3724,7 +3720,7 @@
     gst_ebml_write_buffer_header (ebml, GST_MATROSKA_ID_SIMPLEBLOCK,
         gst_buffer_get_size (buf) + gst_buffer_get_size (hdr));
     gst_ebml_write_buffer (ebml, hdr);
-    gst_ebml_write_flush_cache (ebml, FALSE, buffer_timestamp);
+    gst_ebml_write_flush_cache (ebml, FALSE, GST_BUFFER_TIMESTAMP (buf));
     gst_ebml_write_buffer (ebml, buf);
 
     return gst_ebml_last_write_result (ebml);
@@ -3754,7 +3750,7 @@
     gst_ebml_write_buffer (ebml, hdr);
     gst_ebml_write_master_finish_full (ebml, blockgroup,
         gst_buffer_get_size (buf));
-    gst_ebml_write_flush_cache (ebml, FALSE, buffer_timestamp);
+    gst_ebml_write_flush_cache (ebml, FALSE, GST_BUFFER_TIMESTAMP (buf));
     gst_ebml_write_buffer (ebml, buf);
 
     return gst_ebml_last_write_result (ebml);
@@ -3774,7 +3770,6 @@
 gst_matroska_mux_handle_buffer (GstCollectPads * pads, GstCollectData * data,
     GstBuffer * buf, gpointer user_data)
 {
-  GstClockTime buffer_timestamp;
   GstMatroskaMux *mux = GST_MATROSKA_MUX (user_data);
   GstEbmlWrite *ebml = mux->ebml_write;
   GstMatroskaPad *best;
@@ -3814,17 +3809,15 @@
   /* if we have a best stream, should also have a buffer */
   g_assert (buf);
 
-  buffer_timestamp = gst_matroska_track_get_buffer_timestamp (best->track, buf);
-
   GST_DEBUG_OBJECT (best->collect.pad, "best pad - buffer ts %"
       GST_TIME_FORMAT " dur %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (buffer_timestamp),
+      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
   /* make note of first and last encountered timestamps, so we can calculate
    * the actual duration later when we send an updated header on eos */
-  if (GST_CLOCK_TIME_IS_VALID (buffer_timestamp)) {
-    GstClockTime start_ts = buffer_timestamp;
+  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
+    GstClockTime start_ts = GST_BUFFER_TIMESTAMP (buf);
     GstClockTime end_ts = start_ts;
 
     if (GST_BUFFER_DURATION_IS_VALID (buf))
